// packages/composables/src/hooks/useCms/index.ts
import { ref, computed, watch } from "@vue/composition-api";
import { getCmsPage } from "@shopware-pwa/shopware-6-client";
import { parseUrlQuery } from "@shopware-pwa/helpers";
import merge from "lodash/merge";
function useCms(rootContext) {
  const { apiInstance, contextName } = getApplicationContext(rootContext, "useCms");
  const { sharedRef } = useSharedState(rootContext);
  const _storePage = sharedRef(`${contextName}-page`);
  const { getDefaults } = useDefaults(rootContext, "useCms");
  const { setBreadcrumbs } = useBreadcrumbs(rootContext);
  const error = ref(null);
  const loading = ref(false);
  const page = computed(() => _storePage.value);
  const categoryId = computed(() => {
    return page.value && page.value.resourceIdentifier;
  });
  watch(page, (pageValue) => {
    setBreadcrumbs(Object.values(pageValue?.breadcrumb || []));
  }, { immediate: true });
  const search = async (path, query) => {
    loading.value = true;
    const criteria = parseUrlQuery(query);
    const searchCriteria = merge({}, getDefaults(), criteria);
    try {
      const result = await getCmsPage(path, searchCriteria, apiInstance);
      _storePage.value = result;
    } catch (e) {
      const err = e;
      error.value = err;
    } finally {
      loading.value = false;
    }
  };
  return {
    page,
    categoryId,
    loading,
    search,
    error,
    getBreadcrumbsObject: computed(() => page.value && page.value.breadcrumb || {})
  };
}

// packages/composables/src/hooks/useProduct/index.ts
import { ref as ref2 } from "@vue/composition-api";
import { getProduct, getProductPage } from "@shopware-pwa/shopware-6-client";

// packages/composables/src/appContext.ts
import { getCurrentInstance } from "@vue/composition-api";
function checkAppContext(key, rootContext) {
  if (!rootContext?.$shopwareApiInstance && !rootContext?.shopwareApiInstance) {
    console.warn(`[SECURITY][${key}] Trying to access Application context without Vue instance context. See https://shopware-pwa-docs.vuestorefront.io/landing/fundamentals/security.html#context-awareness`);
    return false;
  }
  if (rootContext.$store || rootContext.store) {
    console.warn(`[PERFORMANCE][${key}] Vuex store detected. Remove "store" directory and useSharedState instead.`);
  }
  return true;
}
function getApplicationContext(rootContext, key = "getApplicationContext") {
  let context = rootContext;
  if (!checkAppContext(key, rootContext)) {
    context = getCurrentInstance();
  }
  return {
    apiInstance: context?.$shopwareApiInstance || context?.shopwareApiInstance,
    vuexStore: context?.$store || context?.store,
    router: context?.$router || context?.router,
    route: context?.$route || context?.route,
    i18n: context?.$i18n || context?.i18n,
    cookies: context?.$cookies || context?.cookies,
    shopwareDefaults: context?.$shopwareDefaults || context?.shopwareDefaults,
    interceptors: context?.$interceptors || context?.interceptors || {},
    routing: context?.$routing || context?.routing,
    sharedStore: context?.$sharedStore || context?.sharedStore,
    instanceStore: context?.$instanceStore || context?.instanceStore,
    isServer: !!(context?.$isServer || context?.isServer || process?.server),
    contextName: key
  };
}

// packages/commons/src/deprecationWarning.ts
function deprecationWarning({
  methodName,
  newMethodName,
  packageName
}) {
  console.warn(`[DEPRECATED][@shopware-pwa/${packageName}][${methodName}] This method has been deprecated. Use "${newMethodName}" instead.`);
}

// packages/commons/src/warning.ts
function warning({
  packageName,
  methodName,
  notes
}) {
  console.warn(`[WARNING][@shopware-pwa/${packageName}][${methodName}]: ${notes}`);
}

// compatibility.json
var shopwareApiVersion = "6.4";
var instances = {
  "6.3": {
    domain: "https://pwa-demo-api.shopware.com/prev/",
    apiKey: "SWSC40-LJTNO6COUEN7CJMXKLA"
  },
  "6.4": {
    domain: "https://pwa-demo-api.shopware.com/trunk/",
    apiKey: "SWSC40-LJTNO6COUEN7CJMXKLA"
  },
  canary: {
    domain: "https://pwa-demo-api.shopware.com/trunk/",
    apiKey: "SWSC40-LJTNO6COUEN7CJMXKLA"
  }
};
var compatibility_default = {
  shopwareApiVersion,
  instances
};

// packages/commons/src/defaultConfig.ts
import merge2 from "lodash/merge";
import axios from "axios";
var defaultPwaConfigFile = {
  shopwareEndpoint: compatibility_default.instances[compatibility_default.shopwareApiVersion].domain,
  shopwareAccessToken: compatibility_default.instances[compatibility_default.shopwareApiVersion].apiKey,
  theme: "@shopware-pwa/default-theme",
  shopwareApiClient: {
    timeout: 1e4
  }
};

// packages/composables/src/logic/useDefaults.ts
var useDefaults = (rootContext, defaultsKey) => {
  const { shopwareDefaults } = getApplicationContext(rootContext, "useDefaults");
  if (!shopwareDefaults) {
    throw new Error("[composables][useDefaults]: applicationContext does not have shopwareDefaults!");
  }
  const getDefaultsFor = (keyName) => {
    if (!shopwareDefaults[keyName]) {
      warning({
        packageName: "composables",
        methodName: "useDefaults",
        notes: `there is no defaults configuration for key: ${keyName}`
      });
      return;
    }
    return shopwareDefaults[keyName];
  };
  const getIncludesConfig = () => getDefaultsFor(defaultsKey)?.includes || {};
  const getAssociationsConfig = () => getDefaultsFor(defaultsKey)?.associations || [];
  const getDefaults = () => getDefaultsFor(defaultsKey) || {};
  return {
    getIncludesConfig,
    getAssociationsConfig,
    getDefaults
  };
};

// packages/composables/src/hooks/useProduct/index.ts
var NO_PRODUCT_REFERENCE_ERROR = "Associations cannot be loaded for undefined product";
var useProduct = (rootContext, loadedProduct) => {
  const { apiInstance } = getApplicationContext(rootContext, "useProduct");
  const { getAssociationsConfig, getIncludesConfig } = useDefaults(rootContext, "useProduct");
  const loading = ref2(false);
  const product = ref2(loadedProduct);
  const error = ref2(null);
  const loadAssociations = async () => {
    if (!product || !product.value || !product.value.id) {
      throw NO_PRODUCT_REFERENCE_ERROR;
    }
    const searchCriteria = {
      configuration: {
        includes: getIncludesConfig(),
        associations: getAssociationsConfig()
      }
    };
    const urlPath = `detail/${product.value.parentId || product.value.id}`;
    const result = await getProductPage(urlPath, searchCriteria, apiInstance);
    product.value = Object.assign({}, product.value, {
      crossSellings: result.product?.crossSellings
    });
  };
  const search = async (productId) => {
    loading.value = true;
    try {
      const result = await getProduct(productId, null, apiInstance);
      product.value = result?.product;
      return result;
    } catch (e) {
      const err = e;
      error.value = err.message;
    } finally {
      loading.value = false;
    }
  };
  return {
    product,
    loading,
    search,
    error,
    loadAssociations
  };
};

// packages/composables/src/hooks/useCart/index.ts
import { ref as ref3, computed as computed2 } from "@vue/composition-api";
import {
  getCart,
  addProductToCart,
  addPromotionCode,
  removeCartItem,
  changeCartItemQuantity
} from "@shopware-pwa/shopware-6-client";

// packages/commons/interfaces/models/common/EntityError.ts
var ErrorLevel;
(function(ErrorLevel2) {
  ErrorLevel2[ErrorLevel2["NOTICE"] = 0] = "NOTICE";
  ErrorLevel2[ErrorLevel2["WARNING"] = 10] = "WARNING";
  ErrorLevel2[ErrorLevel2["ERROR"] = 20] = "ERROR";
})(ErrorLevel || (ErrorLevel = {}));

// packages/composables/src/internalHelpers/errorHandler.ts
var broadcastErrors = (errors, methodName, rootContext) => {
  if (!Array.isArray(errors) || !errors.length || !methodName || !rootContext) {
    return;
  }
  const { broadcast } = useIntercept(rootContext);
  errors.forEach((error) => {
    let interceptorKey;
    switch (error.level) {
      case ErrorLevel.NOTICE:
        interceptorKey = INTERCEPTOR_KEYS.NOTICE;
        break;
      case ErrorLevel.WARNING:
        interceptorKey = INTERCEPTOR_KEYS.WARNING;
        break;
      default:
        interceptorKey = INTERCEPTOR_KEYS.ERROR;
    }
    broadcast(interceptorKey, {
      methodName,
      inputParams: {},
      [interceptorKey]: error
    });
  });
};

// packages/composables/src/hooks/useCart/index.ts
var useCart = (rootContext) => {
  const { apiInstance, contextName } = getApplicationContext(rootContext, "useCart");
  const { broadcast } = useIntercept(rootContext);
  const loading = ref3(false);
  const error = ref3(null);
  const { sharedRef } = useSharedState(rootContext);
  const _storeCart = sharedRef(`${contextName}-cart`);
  async function refreshCart() {
    loading.value = true;
    try {
      const result = await getCart(apiInstance);
      broadcastUpcomingErrors(result);
      _storeCart.value = result;
    } catch (e) {
      const err = e;
      error.value = err.message;
    } finally {
      loading.value = false;
    }
  }
  async function addProduct({
    id,
    quantity
  }) {
    const addToCartResult = await addProductToCart(id, quantity, apiInstance);
    broadcastUpcomingErrors(addToCartResult);
    _storeCart.value = addToCartResult;
  }
  async function removeItem({ id }) {
    const result = await removeCartItem(id, apiInstance);
    broadcastUpcomingErrors(result);
    _storeCart.value = result;
  }
  async function removeProduct({ id }) {
    deprecationWarning({
      methodName: "removeProduct",
      newMethodName: "removeItem",
      packageName: "composables"
    });
    return removeItem({ id });
  }
  async function changeProductQuantity({ id, quantity }) {
    const result = await changeCartItemQuantity(id, quantity, apiInstance);
    broadcastUpcomingErrors(result);
    _storeCart.value = result;
  }
  async function submitPromotionCode(promotionCode) {
    if (promotionCode) {
      const result = await addPromotionCode(promotionCode, apiInstance);
      broadcastUpcomingErrors(result);
      _storeCart.value = result;
      broadcast(INTERCEPTOR_KEYS.ADD_PROMOTION_CODE, {
        result,
        promotionCode
      });
    }
  }
  function broadcastUpcomingErrors(cartResult) {
    if (!cartResult) {
      return;
    }
    try {
      const cartErrorsKeys = Object.keys(_storeCart.value?.errors || {});
      const cartResultErrorKeys = Object.keys(cartResult.errors || {});
      const upcomingErrorsKeys = cartResultErrorKeys.filter((resultErrorKey) => !cartErrorsKeys.includes(resultErrorKey));
      const entityErrors = Object.values(cartResult.errors || {}).filter((entityError) => upcomingErrorsKeys.includes(entityError.key));
      broadcastErrors(entityErrors, `[${contextName}][cartError]`, rootContext);
    } catch (error2) {
      console.error("[useCart][broadcastUpcomingErrors]", error2);
    }
  }
  const appliedPromotionCodes = computed2(() => {
    return cartItems.value.filter((cartItem) => cartItem.type === "promotion");
  });
  const cart = computed2(() => _storeCart.value);
  const cartItems = computed2(() => {
    return cart.value ? cart.value.lineItems || [] : [];
  });
  const count = computed2(() => {
    return cartItems.value.reduce((accumulator, lineItem) => lineItem.type === "product" ? lineItem.quantity + accumulator : accumulator, 0);
  });
  const totalPrice = computed2(() => {
    const cartPrice = cart.value && cart.value.price && cart.value.price.totalPrice;
    return cartPrice || 0;
  });
  const shippingTotal = computed2(() => {
    const shippingTotal2 = cart.value?.deliveries?.[0]?.shippingCosts?.totalPrice;
    return shippingTotal2 || 0;
  });
  const subtotal = computed2(() => {
    const cartPrice = cart.value?.price?.positionPrice;
    return cartPrice || 0;
  });
  const cartErrors = computed2(() => cart.value?.errors && Object.values(cart.value.errors) || []);
  return {
    addProduct,
    addPromotionCode: submitPromotionCode,
    appliedPromotionCodes,
    cart,
    cartItems,
    changeProductQuantity,
    count,
    error,
    loading,
    refreshCart,
    removeProduct,
    removeItem,
    totalPrice,
    shippingTotal,
    subtotal,
    cartErrors
  };
};

// packages/composables/src/logic/useAddToCart.ts
import { ref as ref4, computed as computed3 } from "@vue/composition-api";
var useAddToCart = (rootContext, product) => {
  const { contextName } = getApplicationContext(rootContext, "useAddToCart");
  const { addProduct, cartItems } = useCart(rootContext);
  const { broadcast, intercept } = useIntercept(rootContext);
  const quantity = ref4(1);
  const loading = ref4(false);
  const error = ref4(null);
  const addToCart = async () => {
    if (!product || !product.id) {
      error.value = "Product has to be passed as a composable argument and needs to have an id property.";
      return;
    }
    loading.value = true;
    error.value = null;
    if (!quantity.value)
      quantity.value = 1;
    try {
      await addProduct({ id: product.id, quantity: quantity.value });
      broadcast(INTERCEPTOR_KEYS.ADD_TO_CART, {
        product,
        quantity: quantity.value
      });
      quantity.value = 1;
    } catch (e) {
      const err = e;
      error.value = err;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][addToCart]`,
        inputParams: {
          product,
          quantity: quantity.value
        },
        error: err
      });
    } finally {
      loading.value = false;
    }
  };
  const onAddToCart = (fn) => intercept(INTERCEPTOR_KEYS.ADD_TO_CART, fn);
  const getStock = computed3(() => product && product.stock);
  const getAvailableStock = computed3(() => product && product.availableStock);
  const isInCart = computed3(() => product && cartItems.value.some((item) => item.referencedId === product.id));
  return {
    addToCart,
    quantity,
    error,
    loading,
    getStock,
    getAvailableStock,
    isInCart,
    onAddToCart
  };
};

// packages/composables/src/logic/useCheckout.ts
import {
  computed as computed4,
  reactive
} from "@vue/composition-api";
import {
  getAvailableShippingMethods,
  getAvailablePaymentMethods,
  createOrder as createApiOrder
} from "@shopware-pwa/shopware-6-client";
var useCheckout = (rootContext) => {
  const { apiInstance, contextName } = getApplicationContext(rootContext, "useCheckout");
  const { broadcast, intercept } = useIntercept(rootContext);
  const { refreshCart } = useCart(rootContext);
  const { sessionContext } = useSessionContext(rootContext);
  const { sharedRef } = useSharedState(rootContext);
  const storeShippingMethods = sharedRef(`${contextName}-ShippingMethods`);
  const storePaymentMethods = sharedRef(`${contextName}-PaymentMethods`);
  const loadings = reactive({
    createOrder: false
  });
  const shippingMethods = computed4(() => storeShippingMethods.value || []);
  const paymentMethods = computed4(() => storePaymentMethods.value || []);
  const onOrderPlace = (fn) => intercept(INTERCEPTOR_KEYS.ORDER_PLACE, fn);
  const getShippingMethods = async ({ forceReload } = { forceReload: false }) => {
    if (shippingMethods.value.length && !forceReload)
      return shippingMethods;
    const response = await getAvailableShippingMethods(apiInstance, {
      onlyAvailable: true
    });
    storeShippingMethods.value = response?.elements || [];
    return shippingMethods;
  };
  const getPaymentMethods = async ({ forceReload } = { forceReload: false }) => {
    if (paymentMethods.value.length && !forceReload)
      return paymentMethods;
    const response = await getAvailablePaymentMethods(apiInstance, {
      onlyAvailable: true
    });
    storePaymentMethods.value = response?.elements || [];
    return paymentMethods;
  };
  const createOrder = async () => {
    try {
      loadings.createOrder = true;
      const order = await createApiOrder(apiInstance);
      broadcast(INTERCEPTOR_KEYS.ORDER_PLACE, {
        order
      });
      return order;
    } catch (e) {
      const err = e;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][createOrder]`,
        inputParams: {},
        error: err
      });
      throw err;
    } finally {
      loadings.createOrder = false;
      await refreshCart();
    }
  };
  const shippingAddress = computed4(() => sessionContext.value?.shippingLocation?.address);
  const billingAddress = computed4(() => sessionContext.value?.customer?.activeBillingAddress);
  return {
    getPaymentMethods,
    paymentMethods,
    getShippingMethods,
    shippingMethods,
    createOrder,
    shippingAddress,
    billingAddress,
    onOrderPlace,
    loadings
  };
};

// packages/composables/src/logic/useSessionContext.ts
import { computed as computed5 } from "@vue/composition-api";
import {
  getSessionContext,
  setCurrentShippingMethod,
  setCurrentCurrency,
  setCurrentPaymentMethod,
  setCurrentShippingAddress,
  setCurrentBillingAddress
} from "@shopware-pwa/shopware-6-client";
var useSessionContext = (rootContext) => {
  const { apiInstance } = getApplicationContext(rootContext, "useSessionContext");
  const { broadcast, intercept } = useIntercept(rootContext);
  const { sharedRef } = useSharedState(rootContext);
  const storeSessionContext = sharedRef(`useSessionContext-sessionContext`);
  const onCurrencyChange = (fn) => intercept(INTERCEPTOR_KEYS.SESSION_SET_CURRENCY, fn);
  const onPaymentMethodChange = (fn) => intercept(INTERCEPTOR_KEYS.SESSION_SET_PAYMENT_METHOD, fn);
  const onShippingMethodChange = (fn) => intercept(INTERCEPTOR_KEYS.SESSION_SET_SHIPPING_METHOD, fn);
  const sessionContext = computed5(() => storeSessionContext.value);
  const refreshSessionContext = async () => {
    try {
      const context = await getSessionContext(apiInstance);
      storeSessionContext.value = context;
    } catch (e) {
      console.error("[UseSessionContext][refreshSessionContext]", e);
    }
  };
  const shippingMethod = computed5(() => sessionContext.value?.shippingMethod || null);
  const setShippingMethod = async (shippingMethod2 = {}) => {
    if (!shippingMethod2?.id) {
      throw new Error("You need to provide shipping method id in order to set shipping method.");
    }
    await setCurrentShippingMethod(shippingMethod2.id, apiInstance);
    await refreshSessionContext();
    broadcast(INTERCEPTOR_KEYS.SESSION_SET_SHIPPING_METHOD, {
      shippingMethod: shippingMethod2
    });
  };
  const paymentMethod = computed5(() => sessionContext.value?.paymentMethod || null);
  const setPaymentMethod = async (paymentMethod2 = {}) => {
    if (!paymentMethod2?.id) {
      throw new Error("You need to provide payment method id in order to set payment method.");
    }
    await setCurrentPaymentMethod(paymentMethod2.id, apiInstance);
    await refreshSessionContext();
    broadcast(INTERCEPTOR_KEYS.SESSION_SET_PAYMENT_METHOD, {
      paymentMethod: paymentMethod2
    });
  };
  const currency = computed5(() => sessionContext.value?.currency || null);
  const setCurrency = async (currency2 = {}) => {
    if (!currency2.id) {
      console.error("You need to provide currency id in order to set currency.", currency2);
      return;
    }
    await setCurrentCurrency(currency2.id, apiInstance);
    await refreshSessionContext();
    broadcast(INTERCEPTOR_KEYS.SESSION_SET_CURRENCY, {
      currency: currency2
    });
  };
  const activeShippingAddress = computed5(() => sessionContext.value?.customer?.activeShippingAddress || null);
  const setActiveShippingAddress = async (address) => {
    if (!address?.id) {
      throw new Error("You need to provide address id in order to set the address.");
    }
    await setCurrentShippingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const activeBillingAddress = computed5(() => sessionContext.value?.customer?.activeBillingAddress || null);
  const setActiveBillingAddress = async (address) => {
    if (!address?.id) {
      throw new Error("You need to provide address id in order to set the address.");
    }
    await setCurrentBillingAddress(address.id, apiInstance);
    refreshSessionContext();
  };
  const countryId = computed5(() => sessionContext.value?.salesChannel?.countryId);
  return {
    sessionContext,
    refreshSessionContext,
    shippingMethod,
    setShippingMethod,
    paymentMethod,
    setPaymentMethod,
    currency,
    setCurrency,
    activeShippingAddress,
    setActiveShippingAddress,
    activeBillingAddress,
    setActiveBillingAddress,
    countryId,
    onCurrencyChange,
    onPaymentMethodChange,
    onShippingMethodChange
  };
};

// packages/composables/src/logic/useUIState.ts
import Vue from "vue";
import {
  computed as computed6,
  reactive as reactive2,
  ref as ref5
} from "@vue/composition-api";
var sharedUIState = {};
var useUIState = (rootContext, stateName) => {
  getApplicationContext(rootContext, "useUIState");
  if (stateName && !sharedUIState[stateName]) {
    sharedUIState[stateName] = Vue.observable({ state: false });
  }
  const localMappedState = stateName && reactive2(sharedUIState[stateName]);
  const localState = ref5(false);
  const isOpen = computed6(() => localMappedState?.state || localState.value);
  function switchState(to) {
    if (stateName) {
      const stateToChange = to !== void 0 ? !!to : !sharedUIState[stateName].state;
      sharedUIState[stateName].state = stateToChange;
    } else {
      const stateToChange = to !== void 0 ? !!to : !localState.value;
      localState.value = stateToChange;
    }
  }
  return {
    isOpen,
    switchState
  };
};

// packages/composables/src/hooks/useCategoryFilters/index.ts
import { computed as computed7 } from "@vue/composition-api";
import {
  getCategoryAvailableFilters,
  getCategoryAvailableSorting
} from "@shopware-pwa/helpers";
var useCategoryFilters = (rootContext) => {
  deprecationWarning({
    methodName: "useCategoryFilters",
    newMethodName: "useListing",
    packageName: "composables"
  });
  getApplicationContext(rootContext, "useCategoryFilters");
  const { page } = useCms(rootContext);
  const activeFilters = computed7(() => {
    if (!page || !page.value || !page.value.listingConfiguration) {
      return [];
    }
    return page.value.listingConfiguration.activeFilters;
  });
  const availableFilters = computed7(() => {
    if (!page || !page.value || !page.value.listingConfiguration) {
      return [];
    }
    return getCategoryAvailableFilters({
      filters: page.value.listingConfiguration.availableFilters
    });
  });
  const availableSorting = computed7(() => {
    if (!page || !page.value || !page.value.listingConfiguration) {
      return [];
    }
    return getCategoryAvailableSorting({
      sorting: page.value.listingConfiguration.availableSortings
    });
  });
  const activeSorting = computed7(() => availableSorting.value.find((sorting) => sorting.active));
  return {
    availableFilters,
    activeFilters,
    availableSorting,
    activeSorting
  };
};

// packages/composables/src/hooks/useCurrency.ts
import Vue2 from "vue";
import { reactive as reactive3, computed as computed8 } from "@vue/composition-api";
import { getAvailableCurrencies } from "@shopware-pwa/shopware-6-client";
var sharedCurrencyState = Vue2.observable({
  availableCurrencies: []
});
var useCurrency = (rootContext) => {
  const { apiInstance } = getApplicationContext(rootContext, "useCurrency");
  const { currency, setCurrency: setContextCurrency } = useSessionContext(rootContext);
  const { refreshCart } = useCart(rootContext);
  const localState = reactive3(sharedCurrencyState);
  const currencySymbol = computed8(() => currency.value?.symbol || "");
  const availableCurrencies = computed8(() => {
    if (Array.isArray(localState.availableCurrencies) && localState.availableCurrencies.length) {
      return localState.availableCurrencies;
    }
    return currency.value ? [currency.value] : [];
  });
  const loadAvailableCurrencies = async (options) => {
    if (!options?.forceReload && Array.isArray(localState.availableCurrencies) && localState.availableCurrencies.length)
      return;
    const response = await getAvailableCurrencies(apiInstance);
    sharedCurrencyState.availableCurrencies = response?.elements;
  };
  const setCurrency = async (currency2) => {
    try {
      await setContextCurrency(currency2);
      refreshCart();
    } catch (e) {
      console.error("[useCurrency][setCurrency] Problem with currency change", e);
    }
  };
  return {
    loadAvailableCurrencies,
    setCurrency,
    availableCurrencies,
    currencySymbol,
    currency
  };
};

// packages/composables/src/hooks/useNavigation.ts
import { computed as computed9 } from "@vue/composition-api";
import { getStoreNavigation } from "@shopware-pwa/shopware-6-client";
var useNavigation = (rootContext, params = {
  type: "main-navigation"
}) => {
  const { apiInstance } = getApplicationContext(rootContext, "useNavigation");
  const { sharedRef } = useSharedState(rootContext);
  const { getIncludesConfig, getAssociationsConfig } = useDefaults(rootContext, "useNavigation");
  const sharedElements = sharedRef(`useNavigation-${params.type}`);
  const navigationElements = computed9(() => sharedElements.value);
  const loadNavigationElements = async ({ depth }) => {
    try {
      const navigationResponse = await getStoreNavigation({
        requestActiveId: params.type,
        requestRootId: params.type,
        searchCriteria: {
          configuration: {
            includes: getIncludesConfig(),
            associations: getAssociationsConfig()
          }
        },
        depth
      }, apiInstance);
      sharedElements.value = navigationResponse || [];
    } catch (e) {
      sharedElements.value = [];
      console.error("[useNavigation][loadNavigationElements]", e);
    }
  };
  return {
    navigationElements,
    fetchNavigationElements: (depth) => loadNavigationElements({ depth }),
    loadNavigationElements
  };
};

// packages/composables/src/hooks/useSalutations.ts
import Vue3 from "vue";
import {
  ref as ref6,
  computed as computed10,
  reactive as reactive4,
  onMounted
} from "@vue/composition-api";
import { getAvailableSalutations } from "@shopware-pwa/shopware-6-client";
var sharedSalutations = Vue3.observable({
  salutations: null
});
var useSalutations = (rootContext) => {
  const { apiInstance } = getApplicationContext(rootContext, "useSalutations");
  const localSalutations = reactive4(sharedSalutations);
  const error = ref6(null);
  const fetchSalutations = async () => {
    try {
      const { elements } = await getAvailableSalutations(apiInstance);
      sharedSalutations.salutations = elements;
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const mountedCallback = async () => {
    if (!sharedSalutations.salutations) {
      await fetchSalutations();
    }
  };
  const getSalutations = computed10(() => {
    return localSalutations.salutations ?? [];
  });
  onMounted(mountedCallback);
  return {
    mountedCallback,
    fetchSalutations,
    getSalutations,
    error
  };
};

// packages/composables/src/hooks/useCountries.ts
import Vue4 from "vue";
import {
  computed as computed11,
  ref as ref7,
  reactive as reactive5,
  onMounted as onMounted2
} from "@vue/composition-api";
import { getAvailableCountries } from "@shopware-pwa/shopware-6-client";
var sharedCountries = Vue4.observable({
  countries: null
});
var useCountries = (rootContext) => {
  const { apiInstance } = getApplicationContext(rootContext, "useCountries");
  const localCountries = reactive5(sharedCountries);
  const error = ref7(null);
  const fetchCountries = async () => {
    try {
      const { elements } = await getAvailableCountries(apiInstance);
      sharedCountries.countries = elements;
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const getCountries = computed11(() => {
    return localCountries.countries ?? [];
  });
  const mountedCallback = async () => {
    if (!sharedCountries.countries) {
      await fetchCountries();
    }
  };
  onMounted2(mountedCallback);
  return {
    mountedCallback,
    fetchCountries,
    getCountries,
    error
  };
};

// packages/composables/src/hooks/useUser.ts
import {
  ref as ref8,
  computed as computed12,
  reactive as reactive6
} from "@vue/composition-api";
import {
  login as apiLogin,
  logout as apiLogout,
  register as apiRegister,
  updatePassword as apiUpdatePassword,
  resetPassword as apiResetPassword,
  updateEmail as apiUpdateEmail,
  getCustomer,
  getCustomerOrders,
  getCustomerOrderDetails,
  getCustomerAddresses,
  getUserCountry,
  getUserSalutation,
  setDefaultCustomerBillingAddress,
  setDefaultCustomerShippingAddress,
  deleteCustomerAddress,
  createCustomerAddress,
  updateProfile,
  updateCustomerAddress
} from "@shopware-pwa/shopware-6-client";

// packages/commons/interfaces/models/checkout/customer/CustomerAddress.ts
var AddressType;
(function(AddressType2) {
  AddressType2["billing"] = "billing";
  AddressType2["shipping"] = "shipping";
})(AddressType || (AddressType = {}));

// packages/composables/src/hooks/useUser.ts
var useUser = (rootContext) => {
  const { contextName, apiInstance } = getApplicationContext(rootContext, "useUser");
  const { broadcast, intercept } = useIntercept(rootContext);
  const { refreshSessionContext } = useSessionContext(rootContext);
  const { refreshCart } = useCart(rootContext);
  const { sharedRef } = useSharedState(rootContext);
  const storeUser = sharedRef(`${contextName}-user`);
  const storeAddresses = sharedRef(`${contextName}-addresses`);
  const loading = ref8(false);
  const error = ref8(null);
  const errors = reactive6({
    login: "",
    register: []
  });
  const orders = ref8(null);
  const addresses = computed12(() => storeAddresses.value);
  const country = ref8(null);
  const salutation = ref8(null);
  const user = computed12(() => storeUser.value);
  const login = async ({
    username,
    password
  } = {}) => {
    loading.value = true;
    error.value = null;
    try {
      await apiLogin({ username, password }, apiInstance);
      await refreshUser();
      broadcast(INTERCEPTOR_KEYS.USER_LOGIN, {
        user: user.value
      });
      return true;
    } catch (e) {
      const err = e;
      error.value = err.message;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][login]`,
        inputParams: {},
        error: err
      });
      return false;
    } finally {
      loading.value = false;
      await refreshUser();
      await refreshCart();
    }
  };
  const register = async (params) => {
    loading.value = true;
    errors.register = [];
    try {
      const userObject = await apiRegister(params, apiInstance);
      broadcast(INTERCEPTOR_KEYS.USER_REGISTER);
      storeUser.value = userObject || {};
      refreshSessionContext();
      return true;
    } catch (e) {
      const err = e;
      errors.register = [err.message];
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][register]`,
        inputParams: {},
        error: err
      });
      return false;
    } finally {
      loading.value = false;
    }
  };
  const logout = async () => {
    try {
      await apiLogout(apiInstance);
      broadcast(INTERCEPTOR_KEYS.USER_LOGOUT);
    } catch (e) {
      const err = e;
      error.value = err.message;
      broadcast(INTERCEPTOR_KEYS.ERROR, {
        methodName: `[${contextName}][logout]`,
        inputParams: {},
        error: err
      });
    } finally {
      await refreshUser();
      await refreshCart();
    }
  };
  const onLogout = (fn) => intercept(INTERCEPTOR_KEYS.USER_LOGOUT, fn);
  const onUserLogin = (fn) => intercept(INTERCEPTOR_KEYS.USER_LOGIN, fn);
  const onUserRegister = (fn) => intercept(INTERCEPTOR_KEYS.USER_REGISTER, fn);
  const refreshUser = async () => {
    try {
      const user2 = await getCustomer(apiInstance);
      storeUser.value = user2 || {};
    } catch (e) {
      storeUser.value = {};
      console.error("[useUser][refreshUser]", e);
    }
  };
  const loadOrders = async () => {
    const fetchedOrders = await getCustomerOrders(apiInstance);
    orders.value = fetchedOrders;
  };
  const getOrderDetails = async (orderId) => getCustomerOrderDetails(orderId, apiInstance);
  const loadAddresses = async () => {
    try {
      const response = await getCustomerAddresses(apiInstance);
      storeAddresses.value = response?.elements;
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const loadCountry = async (userId) => {
    try {
      country.value = await getUserCountry(userId, apiInstance);
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const loadSalutation = async (salutationId) => {
    try {
      salutation.value = await getUserSalutation(salutationId, apiInstance);
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const markAddressAsDefault = async ({
    addressId,
    type
  }) => {
    if (!addressId || !type) {
      return false;
    }
    try {
      switch (type) {
        case AddressType.billing:
          await setDefaultCustomerBillingAddress(addressId, apiInstance);
          break;
        case AddressType.shipping:
          await setDefaultCustomerShippingAddress(addressId, apiInstance);
          break;
        default:
          return false;
      }
      await refreshUser();
    } catch (e) {
      const err = e;
      error.value = err.message;
      return false;
    }
    return true;
  };
  const updateAddress = async (params) => {
    try {
      const { id } = await updateCustomerAddress(params, apiInstance);
      return id;
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const addAddress = async (params) => {
    try {
      const { id } = await createCustomerAddress(params, apiInstance);
      return id;
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
  };
  const deleteAddress = async (addressId) => {
    try {
      await deleteCustomerAddress(addressId, apiInstance);
      return true;
    } catch (e) {
      const err = e;
      error.value = err.message;
    }
    return false;
  };
  const updatePersonalInfo = async (personals) => {
    try {
      await updateProfile(personals, apiInstance);
    } catch (e) {
      error.value = e;
      return false;
    }
    return true;
  };
  const updatePassword = async (updatePasswordData) => {
    try {
      await apiUpdatePassword(updatePasswordData, apiInstance);
    } catch (e) {
      error.value = e;
      return false;
    }
    return true;
  };
  const resetPassword = async (resetPasswordData) => {
    try {
      await apiResetPassword(resetPasswordData, apiInstance);
    } catch (e) {
      error.value = e;
      return false;
    }
    return true;
  };
  const updateEmail = async (updateEmailData) => {
    try {
      await apiUpdateEmail(updateEmailData, apiInstance);
    } catch (e) {
      error.value = e;
      return false;
    }
    return true;
  };
  const isLoggedIn = computed12(() => !!user.value?.id);
  const isCustomerSession = computed12(() => !!user.value?.id && !user.value.guest);
  const isGuestSession = computed12(() => !!user.value?.guest);
  return {
    login,
    register,
    user,
    error,
    loading,
    isLoggedIn,
    isCustomerSession,
    isGuestSession,
    refreshUser,
    logout,
    orders,
    loadOrders,
    getOrderDetails,
    loadAddresses,
    addresses,
    markAddressAsDefault,
    updateEmail,
    updatePersonalInfo,
    updatePassword,
    resetPassword,
    addAddress,
    updateAddress,
    deleteAddress,
    loadSalutation,
    salutation,
    loadCountry,
    country,
    errors,
    onLogout,
    onUserLogin,
    onUserRegister
  };
};

// packages/composables/src/logic/useNotifications.ts
import Vue5 from "vue";
import { computed as computed13, reactive as reactive7 } from "@vue/composition-api";
var sharedNotifications = Vue5.observable({
  list: []
});
var useNotifications = (rootContext) => {
  getApplicationContext(rootContext, "useNotifications");
  const localNotifications = reactive7(sharedNotifications);
  const removeOne = (notificationId) => {
    const filteredNotifications = sharedNotifications.list.filter(({ id }) => id !== notificationId);
    sharedNotifications.list = filteredNotifications;
  };
  const removeAll = () => sharedNotifications.list = [];
  const geterateId = () => new Date().getTime();
  const pushNotification = async (message, options) => {
    const timeout = options.timeout || 2500;
    const persistent = !!options.persistent;
    const messageId = geterateId();
    sharedNotifications.list.push({
      id: messageId,
      type: options.type,
      message
    });
    if (!persistent) {
      setTimeout(() => {
        removeOne(messageId);
      }, timeout);
    }
  };
  return {
    removeOne,
    removeAll,
    pushInfo: (message, options = {}) => pushNotification(message, { ...options, type: "info" }),
    pushSuccess: (message, options = {}) => pushNotification(message, { ...options, type: "success" }),
    pushWarning: (message, options = {}) => pushNotification(message, { ...options, type: "warning" }),
    pushError: (message, options = {}) => pushNotification(message, { ...options, type: "danger" }),
    notifications: computed13(() => localNotifications.list)
  };
};

// packages/composables/src/logic/useIntercept.ts
import { getCurrentInstance as getCurrentInstance2, onUnmounted } from "@vue/composition-api";
var INTERCEPTOR_KEYS = {
  ADD_TO_CART: "addToCart",
  ADD_TO_WISHLIST: "addToWishlist",
  ADD_PROMOTION_CODE: "addPromotionCode",
  ERROR: "error",
  WARNING: "warning",
  NOTICE: "notice",
  ORDER_PLACE: "onOrderPlace",
  SESSION_SET_CURRENCY: "onCurrencyChange",
  SESSION_SET_PAYMENT_METHOD: "onPaymentMethodChange",
  SESSION_SET_SHIPPING_METHOD: "onShippingMethodChange",
  USER_LOGOUT: "onUserLogout",
  USER_LOGIN: "onUserLogin",
  USER_REGISTER: "onUserRegister"
};
var useIntercept = (rootContext) => {
  const { interceptors } = getApplicationContext(rootContext, "useIntercept");
  const localSubscribers = [];
  const isVueInstance = !!getCurrentInstance2();
  const broadcast = (broadcastKey, value) => {
    if (interceptors[broadcastKey]?.length) {
      interceptors[broadcastKey].forEach((broadcastMethod) => broadcastMethod(value, rootContext));
    }
  };
  const intercept = (broadcastKey, method) => {
    if (!interceptors[broadcastKey])
      interceptors[broadcastKey] = [];
    interceptors[broadcastKey].push(method);
    isVueInstance && localSubscribers.push({ broadcastKey, method });
  };
  const disconnect = (broadcastKey, method) => {
    interceptors[broadcastKey] = interceptors[broadcastKey]?.filter((subscribedMethod) => subscribedMethod !== method) || [];
  };
  isVueInstance && onUnmounted(() => {
    localSubscribers.forEach(({ broadcastKey, method }) => {
      disconnect(broadcastKey, method);
    });
  });
  return {
    broadcast,
    intercept,
    disconnect
  };
};

// packages/composables/src/internalHelpers/defaultApiParams.json
var useCms2 = {
  limit: 10,
  associations: {
    manufacturer: {
      associations: {
        media: {}
      }
    },
    media: {
      sort: [
        {
          field: "position",
          order: "ASC",
          naturalSorting: false
        }
      ]
    },
    productReviews: {},
    crossSellings: {
      associations: {
        assignedProducts: {
          associations: {
            product: {
              associations: {
                media: {},
                cover: {},
                seoUrls: {}
              }
            }
          }
        }
      }
    },
    properties: {
      associations: {
        group: {}
      }
    }
  },
  includes: {
    cms_page_slot: [
      "id",
      "type",
      "slot",
      "blockId",
      "config",
      "data",
      "backgroundMediaMode",
      "backgroundMedia"
    ],
    cms_page_block: [
      "slots",
      "type",
      "id",
      "backgroundColor",
      "backgroundMedia",
      "sectionPosition"
    ],
    cms_page_section: [
      "id",
      "backgroundMedia",
      "blocks",
      "type",
      "sizingMode"
    ],
    cms_page: ["id", "name", "sections", "type", "config"],
    product: [
      "media",
      "productReviews",
      "name",
      "description",
      "ratingAverage",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "parentId",
      "id",
      "translated",
      "optionIds",
      "properties",
      "manufacturer",
      "seoUrls",
      "crossSellings",
      "availableStock",
      "customFields",
      "stock"
    ],
    product_media: ["media"],
    media: ["thumbnails", "width", "height", "url"],
    media_thumbnail: ["url", "width", "height", "id"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["id", "group", "translated", "name"],
    product_group: ["id", "translated", "name"],
    product_listing: [
      "sorting",
      "currentFilters",
      "elements",
      "page",
      "limit",
      "sortings",
      "availableSortings",
      "total",
      "aggregations"
    ],
    property_group: ["id", "translated", "options", "name"],
    property_group_option: [
      "translated",
      "name",
      "id",
      "colorHexCode",
      "media",
      "group"
    ],
    product_manufacturer: ["translated", "link", "name"]
  }
};
var useProductListing = {
  limit: 10,
  includes: {
    product: [
      "name",
      "ratingAverage",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "id",
      "translated",
      "options",
      "seoUrls"
    ],
    product_media: ["media"],
    media: ["thumbnails", "width", "height", "url"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["name", "id", "group", "translated"],
    product_group: ["id", "name", "options", "translated"],
    property_group: ["id", "translated", "options"],
    property_group_option: [
      "translated",
      "name",
      "id",
      "colorHexCode",
      "media",
      "group"
    ]
  }
};
var useProductQuickSearch = {
  limit: 10,
  includes: {
    calculated_price: ["unitPrice", "quantity", "listPrice"]
  }
};
var useListing = {
  limit: 10,
  includes: {
    product: [
      "name",
      "ratingAverage",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "id",
      "translated",
      "options",
      "seoUrls"
    ],
    product_media: ["media"],
    media: ["thumbnails", "width", "height", "url"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["name", "id", "group", "translated"],
    product_group: ["id", "name", "options", "translated"],
    property_group: ["id", "translated", "options"],
    property_group_option: [
      "name",
      "translated",
      "id",
      "colorHexCode",
      "media",
      "group"
    ]
  }
};
var useProduct2 = {
  associations: {
    crossSellings: {
      associations: {
        assignedProducts: {
          associations: {
            product: {
              associations: {
                media: {},
                cover: {},
                seoUrls: {}
              }
            }
          }
        }
      }
    },
    media: {
      sort: [
        {
          field: "position",
          order: "ASC",
          naturalSorting: false
        }
      ]
    }
  },
  includes: {
    product: [
      "name",
      "ratingAverage",
      "calculatedPrice",
      "calculatedPrices",
      "calculatedListingPrice",
      "cover",
      "id",
      "parentId",
      "translated",
      "media",
      "seoUrls",
      "crossSellings",
      "availableStock",
      "customFields"
    ],
    product_media: ["media"],
    media: ["url"],
    media_thumbnail: ["url", "width", "height", "id"],
    calculated_price: ["unitPrice", "quantity", "listPrice"],
    product_group_option: ["name", "id", "group", "translated"],
    product_group: ["id", "name", "translated"]
  }
};
var useNavigation2 = {
  associations: {
    seoUrls: {}
  },
  includes: {
    category: [
      "seoUrls",
      "externalLink",
      "name",
      "id",
      "children",
      "translated",
      "type"
    ],
    seo_url: ["pathInfo", "seoPathInfo"]
  }
};
var defaultApiParams_default = {
  useCms: useCms2,
  useProductListing,
  useProductQuickSearch,
  useListing,
  useProduct: useProduct2,
  useNavigation: useNavigation2
};

// packages/composables/src/getDefaultApiParams.ts
function getDefaultApiParams() {
  return defaultApiParams_default;
}

// packages/composables/src/logic/useListing.ts
import {
  getCategoryProducts,
  searchProducts
} from "@shopware-pwa/shopware-6-client";
var useListing2 = (rootContext, listingKey = "categoryListing") => {
  const { getDefaults } = useDefaults(rootContext, "useListing");
  const { apiInstance } = getApplicationContext(rootContext, "useListing");
  let searchMethod;
  if (listingKey === "productSearchListing") {
    searchMethod = async (searchCriteria) => {
      return searchProducts(searchCriteria, apiInstance);
    };
  } else {
    const { categoryId } = useCms(rootContext);
    searchMethod = async (searchCriteria) => {
      if (!categoryId.value) {
        throw new Error("[useListing][search] Search category id does not exist.");
      }
      return getCategoryProducts(categoryId.value, searchCriteria, apiInstance);
    };
  }
  return createListingComposable({
    rootContext,
    listingKey,
    searchMethod,
    searchDefaults: getDefaults()
  });
};

// packages/composables/src/logic/useProductQuickSearch.ts
import { searchSuggestedProducts } from "@shopware-pwa/shopware-6-client";
import { ref as ref9 } from "@vue/composition-api";
var useProductQuickSearch2 = (rootContext) => {
  const { getDefaults } = useDefaults(rootContext, "useProductQuickSearch");
  const { apiInstance } = getApplicationContext(rootContext, "useListing");
  const searchTerm = ref9("");
  const listingKey = "productQuickSearch";
  const searchMethod = async (searchCriteria) => {
    return searchSuggestedProducts(searchCriteria, apiInstance);
  };
  const listingComposable = createListingComposable({
    rootContext,
    listingKey,
    searchMethod,
    searchDefaults: getDefaults()
  });
  const search = async (additionalCriteria = {}) => {
    const searchCriteria = {
      query: searchTerm.value,
      ...additionalCriteria
    };
    return listingComposable.search(searchCriteria, {
      preventRouteChange: true
    });
  };
  return {
    searchTerm,
    loading: listingComposable.loading,
    search,
    loadMore: listingComposable.loadMore,
    getProducts: listingComposable.getElements,
    getTotal: listingComposable.getTotal
  };
};

// packages/composables/src/factories/createListingComposable.ts
import { getListingFilters } from "@shopware-pwa/helpers";
import { computed as computed14, ref as ref10 } from "@vue/composition-api";
import merge3 from "lodash/merge";
function createListingComposable({
  rootContext,
  searchMethod,
  searchDefaults,
  listingKey
}) {
  const { router, contextName } = getApplicationContext(rootContext, "createListingComposable");
  const loading = ref10(false);
  const loadingMore = ref10(false);
  const { sharedRef } = useSharedState(rootContext);
  const _storeInitialListing = sharedRef(`${contextName}-initialListing-${listingKey}`);
  const _storeAppliedListing = sharedRef(`${contextName}-appliedListing-${listingKey}`);
  const getInitialListing = computed14(() => _storeInitialListing.value);
  const setInitialListing = async (initialListing) => {
    if (initialListing?.currentFilters?.manufacturer?.length || initialListing?.currentFilters?.properties?.length) {
      loading.value = true;
      const allFiltersResult = await searchMethod({
        query: initialListing.currentFilters.search || void 0
      });
      initialListing = Object.assign({}, initialListing, {
        aggregations: allFiltersResult?.aggregations
      });
    }
    _storeInitialListing.value = initialListing;
    _storeAppliedListing.value = null;
    loading.value = false;
  };
  const initSearch = async (criteria) => {
    loading.value = true;
    try {
      const searchCriteria = merge3({}, searchDefaults, criteria);
      const result = await searchMethod(searchCriteria);
      await setInitialListing(result);
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  };
  const search = async (criteria, options) => {
    loading.value = true;
    const changeRoute = options?.preventRouteChange !== true;
    try {
      changeRoute && router.replace({
        query: {
          ...criteria
        }
      }).catch(() => {
      });
      const searchCriteria = merge3({}, searchDefaults, criteria);
      const result = await searchMethod(searchCriteria);
      const allFiltersResult = await searchMethod({
        query: searchCriteria.query,
        includes: { product_listing: ["aggregations"] }
      });
      _storeAppliedListing.value = Object.assign({}, result, {
        aggregations: allFiltersResult?.aggregations
      });
    } catch (e) {
      throw e;
    } finally {
      loading.value = false;
    }
  };
  const loadMore = async () => {
    loadingMore.value = true;
    try {
      const query = {
        ...router.currentRoute.query,
        p: getCurrentPage.value + 1
      };
      const searchCriteria = merge3({}, searchDefaults, query);
      const result = await searchMethod(searchCriteria);
      _storeAppliedListing.value = {
        ...getCurrentListing.value,
        page: result.page,
        elements: [
          ...getCurrentListing.value?.elements || [],
          ...result.elements
        ]
      };
    } catch (e) {
      throw e;
    } finally {
      loadingMore.value = false;
    }
  };
  const getCurrentListing = computed14(() => {
    return _storeAppliedListing.value || getInitialListing.value;
  });
  const getElements = computed14(() => {
    return getCurrentListing.value?.elements || [];
  });
  const getTotal = computed14(() => {
    return getCurrentListing.value?.total || 0;
  });
  const getLimit = computed14(() => {
    return getCurrentListing.value?.limit || searchDefaults?.limit || 10;
  });
  const getTotalPagesCount = computed14(() => Math.ceil(getTotal.value / getLimit.value));
  const getSortingOrders = computed14(() => {
    const oldSortings = Object.values(getCurrentListing.value?.sortings || {});
    return getCurrentListing.value?.availableSortings || oldSortings;
  });
  const getCurrentSortingOrder = computed14(() => getCurrentListing.value?.sorting);
  const changeCurrentSortingOrder = async (order) => {
    const query = {
      ...router.currentRoute.query,
      order
    };
    await search(query);
  };
  const getCurrentPage = computed14(() => getCurrentListing.value?.page || 1);
  const changeCurrentPage = async (pageNumber) => {
    const query = {
      ...router.currentRoute.query,
      p: pageNumber || 1
    };
    await search(query);
  };
  const getAvailableFilters = computed14(() => {
    return getListingFilters(getCurrentListing.value?.aggregations);
  });
  const getCurrentFilters = computed14(() => {
    const currentFiltersResult = {};
    const currentFilters = {
      ...getCurrentListing.value?.currentFilters,
      ...router.currentRoute.query
    };
    Object.keys(currentFilters).forEach((objectKey) => {
      if (!currentFilters[objectKey])
        return;
      if (objectKey === "navigationId")
        return;
      if (objectKey === "price") {
        if (currentFilters[objectKey].min)
          currentFiltersResult["min-price"] = currentFilters[objectKey].min;
        if (currentFilters[objectKey].max)
          currentFiltersResult["max-price"] = currentFilters[objectKey].max;
        return;
      }
      if (objectKey === "p")
        return;
      currentFiltersResult[objectKey] = currentFilters[objectKey];
    });
    return currentFiltersResult;
  });
  return {
    getInitialListing,
    setInitialListing,
    initSearch,
    search,
    getCurrentListing,
    getElements,
    getSortingOrders,
    getCurrentSortingOrder,
    changeCurrentSortingOrder,
    getCurrentPage,
    changeCurrentPage,
    getTotal,
    getTotalPagesCount,
    getLimit,
    getAvailableFilters,
    getCurrentFilters,
    loading,
    loadMore,
    loadingMore
  };
}

// packages/composables/src/logic/useWishlist.ts
import Vue6 from "vue";
import { ref as ref11, reactive as reactive8, computed as computed15, onMounted as onMounted3 } from "@vue/composition-api";
var sharedWishlist = Vue6.observable({
  items: []
});
var useWishlist = (rootContext, product) => {
  const { broadcast, intercept } = useIntercept(rootContext);
  getApplicationContext(rootContext, "useNotifications");
  const localWishlist = reactive8(sharedWishlist);
  const productId = ref11(product?.id);
  const onAddToWishlist = (fn) => intercept(INTERCEPTOR_KEYS.ADD_TO_WISHLIST, fn);
  const updateStorage = () => {
    localStorage.setItem("sw-wishlist-items", JSON.stringify(sharedWishlist.items));
  };
  const getFromStorage = () => {
    if (typeof window != "undefined" && localStorage) {
      return JSON.parse(localStorage.getItem("sw-wishlist-items") ?? "[]");
    }
  };
  onMounted3(() => {
    if (!sharedWishlist.items.length) {
      try {
        const currentWishlist = getFromStorage();
        if (Array.isArray(currentWishlist) && currentWishlist.length) {
          sharedWishlist.items = currentWishlist;
        }
      } catch (error) {
        console.error("useWishlist:getFromStorage", error);
      }
    }
  });
  const removeFromWishlist = (itemId) => {
    const id = productId.value || itemId;
    if (!id) {
      return;
    }
    sharedWishlist.items = sharedWishlist.items.filter((itemId2) => itemId2 != id);
    updateStorage();
  };
  const addToWishlist = () => {
    if (!productId.value) {
      return;
    }
    if (!sharedWishlist.items.includes(productId.value)) {
      sharedWishlist.items.push(productId.value);
      updateStorage();
      broadcast(INTERCEPTOR_KEYS.ADD_TO_WISHLIST, {
        product
      });
    }
  };
  const isInWishlist = computed15(() => {
    return localWishlist.items.includes(productId.value);
  });
  const clearWishlist = () => {
    sharedWishlist.items = [];
  };
  const items = computed15(() => localWishlist.items);
  const count = computed15(() => items.value.length);
  return {
    addToWishlist,
    removeFromWishlist,
    isInWishlist,
    clearWishlist,
    items,
    count,
    onAddToWishlist
  };
};

// packages/composables/src/hooks/useCountry.ts
import { computed as computed16 } from "@vue/composition-api";
var useCountry = (countryId, countries) => {
  const currentCountry = computed16(() => {
    if (!countryId.value)
      return null;
    return countries.value.find((country) => country.id === countryId.value) ?? null;
  });
  const displayState = computed16(() => {
    return currentCountry.value?.forceStateInRegistration ?? false;
  });
  const forceState = computed16(() => {
    return currentCountry.value?.forceStateInRegistration ?? false;
  });
  return {
    currentCountry,
    displayState,
    forceState
  };
};

// packages/composables/src/logic/useProductConfigurator.ts
import { ref as ref12, computed as computed17 } from "@vue/composition-api";
import {
  invokePost,
  getProductEndpoint
} from "@shopware-pwa/shopware-6-client";
var useProductConfigurator = (rootContext, product) => {
  const { page } = useCms(rootContext);
  const selected = ref12({});
  const isLoadingOptions = ref12(!!product.options?.length);
  const parentProductId = computed17(() => product.parentId);
  const getOptionGroups = computed17(() => page.value.configurator || []);
  const findGroupCodeForOption = (optionId) => {
    const group = getOptionGroups.value.find((optionGroup) => {
      const optionFound = optionGroup.options.find((option) => option.id === optionId);
      return !!optionFound;
    });
    return group?.translated?.name;
  };
  product.optionIds?.forEach((optionId) => {
    const optionGroupCode = findGroupCodeForOption(optionId);
    if (optionGroupCode) {
      selected.value[optionGroupCode] = optionId;
    }
  });
  const findVariantForSelectedOptions = async (options) => {
    const { apiInstance } = getApplicationContext(rootContext, "useProductConfigurator");
    const filter = [
      {
        type: "equals",
        field: "parentId",
        value: parentProductId.value
      },
      ...Object.values(options || selected.value).map((id) => ({
        type: "equals",
        field: "optionIds",
        value: id
      }))
    ];
    try {
      if (apiInstance) {
        apiInstance.defaults.headers["sw-include-seo-urls"] = true;
      }
      const response = await invokePost({
        address: getProductEndpoint(),
        payload: {
          limit: 1,
          filter,
          includes: {
            product: ["id", "translated", "productNumber", "seoUrls"],
            seo_url: ["seoPathInfo"]
          },
          associations: {
            seoUrls: {}
          }
        }
      }, apiInstance);
      return response?.data?.elements?.[0];
    } catch (e) {
      console.error("SwProductDetails:findVariantForSelectedOptions", e);
    }
  };
  const handleChange = async (group, option, onChangeHandled) => {
    selected.value = Object.assign({}, selected.value, {
      [group]: option
    });
    if (typeof onChangeHandled === "function") {
      await onChangeHandled();
    }
  };
  return {
    handleChange,
    findVariantForSelectedOptions,
    isLoadingOptions,
    getOptionGroups,
    getSelectedOptions: selected
  };
};

// packages/composables/src/logic/useBreadcrumbs.ts
import Vue7 from "vue";
import { computed as computed18, reactive as reactive9 } from "@vue/composition-api";
var sharedBreadcrumbs = Vue7.observable({
  list: []
});
function useBreadcrumbs(rootContext, params) {
  const { i18n } = getApplicationContext(rootContext, "useBreadcrumbs");
  let localBreadcrumbs = reactive9(sharedBreadcrumbs);
  const clear = () => {
    sharedBreadcrumbs.list = [];
  };
  const setBreadcrumbs = (breadcrumbs) => {
    sharedBreadcrumbs.list = breadcrumbs || [];
  };
  return {
    clear,
    setBreadcrumbs,
    breadcrumbs: computed18(() => {
      if (!!params?.hideHomeLink || !localBreadcrumbs.list.length)
        return localBreadcrumbs.list;
      return [
        {
          name: i18n.t("Home"),
          path: "/"
        },
        ...localBreadcrumbs.list
      ];
    })
  };
}

// packages/composables/src/logic/useProductAssociations.ts
import { ref as ref13, computed as computed19 } from "@vue/composition-api";
import {
  invokeGet,
  invokePost as invokePost2,
  getProductDetailsEndpoint
} from "@shopware-pwa/shopware-6-client";
function useProductAssociations(rootContext, product, association) {
  const { apiInstance } = getApplicationContext(rootContext, "useProductAssociations");
  const isLoading = ref13(false);
  const associations = ref13([]);
  const loadAssociations = async ({
    method,
    params
  } = {}) => {
    isLoading.value = true;
    try {
      if (method && method === "get") {
        const response2 = await invokeGet({
          address: `${getProductDetailsEndpoint(product.id)}/${association}${params ? params : ""}`
        }, apiInstance);
        associations.value = response2?.data;
        return;
      }
      const response = await invokePost2({
        address: `${getProductDetailsEndpoint(product.id)}/${association}`,
        payload: params
      }, apiInstance);
      associations.value = response?.data;
    } catch (error) {
      console.error("[useProductAssociations][loadAssociations][error]:", error);
    } finally {
      isLoading.value = false;
    }
  };
  return {
    isLoading: computed19(() => isLoading.value),
    productAssociations: computed19(() => associations.value || []),
    loadAssociations
  };
}

// packages/composables/src/logic/useSharedState.ts
import {
  computed as computed20,
  onServerPrefetch,
  getCurrentInstance as getCurrentInstance3,
  ref as ref14,
  toRef
} from "@vue/composition-api";
var localSharedState = {};
function useSharedState(rootContext) {
  const { sharedStore, isServer } = getApplicationContext(rootContext, "useSharedState");
  function sharedRef(uniqueKey) {
    if (!isServer && !localSharedState[uniqueKey]) {
      localSharedState[uniqueKey] = ref14(sharedStore[uniqueKey]);
    }
    const sharedRef2 = isServer ? toRef(sharedStore, uniqueKey) : localSharedState[uniqueKey];
    return computed20({
      get: () => {
        return sharedRef2.value || null;
      },
      set: (val) => {
        sharedRef2.value = val;
      }
    });
  }
  async function preloadRef(refObject, callback) {
    if (!refObject.value) {
      if (isServer && getCurrentInstance3()) {
        onServerPrefetch(async () => {
          await callback();
        });
        return;
      }
      await callback();
    }
  }
  return {
    sharedRef,
    preloadRef
  };
}
export {
  INTERCEPTOR_KEYS,
  createListingComposable,
  getApplicationContext,
  getDefaultApiParams,
  useAddToCart,
  useBreadcrumbs,
  useCart,
  useCategoryFilters,
  useCheckout,
  useCms,
  useCountries,
  useCountry,
  useCurrency,
  useDefaults,
  useIntercept,
  useListing2 as useListing,
  useNavigation,
  useNotifications,
  useProduct,
  useProductAssociations,
  useProductConfigurator,
  useProductQuickSearch2 as useProductQuickSearch,
  useSalutations,
  useSessionContext,
  useSharedState,
  useUIState,
  useUser,
  useWishlist
};
